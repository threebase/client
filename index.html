<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Threebase</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="node_modules/three/build/three.js"></script>
    <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
    <style>
    #game{
        position: fixed;
        top: 8px;
        left: 8px;
        width: 800px;
        height: 600px;
    }
    </style>
    <script src="game/GAME_CONFIG.js"></script>
    <script src="game/Player.js"></script>
    <script src="abstract/Utility.js"></script>
    <script src="abstract/Layers.js"></script>
</head>
<body>

    <div id="game"></div>

    <script>
        const gameElement = document.getElementById("game");

        const player = new Player({
            id: Math.random()
        });
        const characters = [player];

        const threejsLayer = new ThreeLayer({
            target: gameElement,
            initCharacters: layer => {
                console.log('characters === ',characters);
                characters.forEach((character, i) => {
                    console.log('character === ',character);
                    const spriteId = `character${i}`;
                    console.log('spriteId === ',spriteId);
                    const spriteOptions = character.spriteSheets[character.animation];

                    const texture = Utility.spriteSheetTexture(spriteId, spriteOptions);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.LinearFilter;
                    // texture.minFilter = THREE.LinearMipMapLinearFilter;

                    const characterMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        alphaTest: 1
                    });
                    const characterGeometry = new THREE.PlaneGeometry(2, 2, 1);
                    const characterMesh = new THREE.Mesh(characterGeometry, characterMaterial);

                    characterMesh.renderOrder = 2;
                    characterMesh.position.x = character.x;
                    characterMesh.position.y = character.y;
                    characterMesh.position.z = character.z;
                    characterMesh.rotation.y = Math.PI/2;
                    layer.scene.add(characterMesh);
                })
            },
            initWorld: layer => {
                const groundGeometry = new THREE.PlaneGeometry(512, 1024);
                const height = 128;
                const wallGeometryArr = [
                    new THREE.PlaneGeometry(groundGeometry.height, height),
                    new THREE.PlaneGeometry(groundGeometry.width, height),
                    new THREE.PlaneGeometry(groundGeometry.height, height),
                    new THREE.PlaneGeometry(groundGeometry.width, height)
                ]
                const obstacleGeometryArr = [
                    new THREE.CubeGeometry(64, 64, 64)
                ]
                // Set the material, the "skin"
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0xF5F5F5
                });
                let i = 0;
                // Set the "world" modelisation object
                const mesh = new THREE.Object3D();
                // Set and add the ground
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                mesh.add(ground);
                // Set and add the walls
                const walls = [];
                for (i = 0; i < wallGeometryArr.length; i += 1) {
                    walls[i] = new THREE.Mesh(wallGeometryArr[i], groundMaterial);
                    walls[i].position.y = height / 2;
                    mesh.add(walls[i]);
                }
                walls[0].rotation.y = -Math.PI / 2;
                walls[0].position.x = groundGeometry.width / 2;
                walls[1].rotation.y = Math.PI;
                walls[1].position.z = groundGeometry.height / 2;
                walls[2].rotation.y = Math.PI / 2;
                walls[2].position.x = -groundGeometry.width / 2;
                walls[3].position.z = -groundGeometry.height / 2;
                // Set and add the obstacles
                const obstacles = [];
                const obstacleMaterial = new THREE.MeshLambertMaterial({
                    color: 0xF0F0F0
                });
                for (i = 0; i < obstacleGeometryArr.length; i += 1) {
                    obstacles[i] = new THREE.Mesh(obstacleGeometryArr[i], obstacleMaterial);
                    mesh.add(obstacles[i]);
                }
                obstacles[0].position.set(0, 32, 128);
            },
            initLights: layer => {
                layer.light = new THREE.PointLight();
                layer.light.position.set(-256, 256, -256);
                layer.scene.add(layer.light);
            },
            initCamera: layer => {
                layer.camera = new THREE.PerspectiveCamera(75, layer.width / layer.height, 0.1, 1000);
                layer.camera.position.x = 0;
                layer.camera.position.y = 1.8;
                layer.camera.position.z = 3;
                layer.cameraControls = new THREE.OrbitControls(layer.camera, layer.renderer.domElement);
                layer.cameraControls.enablePan = false;
                layer.camera.position.set(10, 30, 10);
                layer.cameraControls.update();
            }
        });
        const guiLayer = new HtmlLayer({
            target: gameElement,
            elements: GAME_CONFIG.guiElements,
            buttons: GAME_CONFIG.guiButtons
        })

        window.onkeydown = function(ev) {
            GAME_CONFIG.playerControls.move.onkeydown(player, ev.keyCode);
        }
        window.onkeyup = function(ev) {
            GAME_CONFIG.guiButtons.forEach(buttonOptions => {
                console.log('ev.key === ',ev.key);
                if (ev.key === buttonOptions.hotkey) {
                    Utility.clickIconButton(buttonOptions);
                }
            });
            GAME_CONFIG.playerControls.move.onkeyup(player, ev.keyCode);
        }

        threejsLayer.render();

    
    </script>
</body>
</html>